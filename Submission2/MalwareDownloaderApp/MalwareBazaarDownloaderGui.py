import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import requests
import csv
import os
import time
import json
from datetime import datetime
from threading import Semaphore, Thread
import configparser
import subprocess
import platform

class MalwareBazaarDownloaderGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("MalwareBazaar APT Downloader - Enhanced")
        # Make window 3 times larger
        self.root.geometry("1400x1100")
        
        # Configure font scaling (3x larger)
        self.font_scale = 3
        self.title_font = ('Arial', 18 * self.font_scale // 2, 'bold')
        self.large_font = ('Arial', 14 * self.font_scale // 2)
        self.medium_font = ('Arial', 12 * self.font_scale // 2)
        self.small_font = ('Arial', 10 * self.font_scale // 2)
        
        # Apply larger fonts to all widgets
        self.style = ttk.Style()
        self.style.configure('.', font=self.medium_font)
        self.style.configure('TButton', font=self.medium_font, padding=10)
        self.style.configure('TLabel', font=self.medium_font)
        self.style.configure('TEntry', font=self.medium_font)
        self.style.configure('TCombobox', font=self.medium_font)
        self.style.configure('TLabelframe', font=self.large_font)
        self.style.configure('TLabelframe.Label', font=self.large_font)
        
        # Initialize downloader
        self.downloader = None
        self.download_thread = None
        self.stop_download = False
        
        # Statistics
        self.total_downloaded = 0
        self.total_failed = 0
        self.total_skipped = 0
        
        # Load configuration
        self.config = configparser.ConfigParser()
        self.config_file = "malwarebazaar_config.ini"
        self.load_config()
        
        self.setup_gui()
        
    def load_config(self):
        """Load configuration from file"""
        if os.path.exists(self.config_file):
            try:
                self.config.read(self.config_file)
                if not self.config.has_section('API'):
                    self.config['API'] = {}
            except configparser.Error as e:
                print(f"Config file error: {e}. Creating new config.")
                self.create_default_config()
        else:
            self.create_default_config()
    
    def create_default_config(self):
        """Create default configuration"""
        self.config['API'] = {'key': 'INSERT_YOUR_MALWAREBAZAAR_API_KEY'}
        self.save_config()
    
    def save_config(self):
        """Save configuration to file"""
        try:
            with open(self.config_file, 'w') as configfile:
                self.config.write(configfile)
        except Exception as e:
            print(f"Error saving config: {e}")
    
    def setup_gui(self):
        """Setup the enhanced GUI interface"""
        # Create main frame with larger padding
        main_frame = ttk.Frame(self.root, padding="25")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights for responsiveness
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        
        # Title with larger font
        title_label = ttk.Label(main_frame, 
                               text="üîç MalwareBazaar APT Malware Downloader üîç", 
                               font=self.title_font,
                               foreground='dark blue')
        title_label.grid(row=0, column=0, columnspan=4, pady=(0, 30))
        
        # API Configuration Section
        api_frame = ttk.LabelFrame(main_frame, text="üîë API Configuration", padding="20")
        api_frame.grid(row=1, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(0, 20))
        api_frame.columnconfigure(1, weight=1)
        
        ttk.Label(api_frame, text="API Key:", font=self.medium_font).grid(
            row=0, column=0, sticky=tk.W, padx=(0, 20))
        
        api_key = self.config.get('API', 'key', fallback='INSERT_YOUR_MALWAREBAZAAR_API_KEY')
        self.api_key_var = tk.StringVar(value=api_key)
        
        self.api_key_entry = ttk.Entry(api_frame, textvariable=self.api_key_var, 
                                      width=80, show="*", font=self.medium_font)
        self.api_key_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 20))
        
        # API Control Buttons
        api_button_frame = ttk.Frame(api_frame)
        api_button_frame.grid(row=0, column=2, columnspan=3, sticky=(tk.W, tk.E))
        
        ttk.Button(api_button_frame, text="üíæ Save API Key", 
                  command=self.save_api_key).grid(row=0, column=0, padx=(0, 15))
        
        self.show_key_var = tk.BooleanVar(value=False)
        ttk.Checkbutton(api_button_frame, text="üëÅÔ∏è Show", variable=self.show_key_var,
                       command=self.toggle_api_key_visibility).grid(row=0, column=1, padx=(0, 15))
        
        ttk.Button(api_button_frame, text="üß™ Test API", 
                  command=self.test_api).grid(row=0, column=2)
        
        # API Status Indicator
        self.api_status_var = tk.StringVar(value="üî¥ API: Not Tested")
        api_status_label = ttk.Label(api_frame, textvariable=self.api_status_var, 
                                    font=self.medium_font, foreground='red')
        api_status_label.grid(row=1, column=0, columnspan=4, sticky=tk.W, pady=(15, 0))
        
        # APT Group Information Section
        apt_frame = ttk.LabelFrame(main_frame, text="üéØ APT Group Information", padding="20")
        apt_frame.grid(row=2, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(0, 20))
        apt_frame.columnconfigure(1, weight=1)
        apt_frame.columnconfigure(3, weight=1)
        
        # Group Name
        ttk.Label(apt_frame, text="Group Name:", font=self.medium_font).grid(
            row=0, column=0, sticky=tk.W, padx=(0, 20))
        self.group_name_var = tk.StringVar()
        self.group_name_entry = ttk.Entry(apt_frame, textvariable=self.group_name_var, 
                                         width=40, font=self.medium_font)
        self.group_name_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 30))
        
        # MITRE ID
        ttk.Label(apt_frame, text="MITRE ID:", font=self.medium_font).grid(
            row=0, column=2, sticky=tk.W, padx=(0, 20))
        self.mitre_id_var = tk.StringVar()
        self.mitre_id_entry = ttk.Entry(apt_frame, textvariable=self.mitre_id_var, 
                                       width=20, font=self.medium_font)
        self.mitre_id_entry.grid(row=0, column=3, sticky=(tk.W, tk.E))
        
        # Country
        ttk.Label(apt_frame, text="Country:", font=self.medium_font).grid(
            row=1, column=0, sticky=tk.W, padx=(0, 20))
        self.country_var = tk.StringVar()
        self.country_entry = ttk.Entry(apt_frame, textvariable=self.country_var, 
                                      width=40, font=self.medium_font)
        self.country_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), padx=(0, 30))
        
        # Predefined APT groups dropdown with all 36 groups
        ttk.Label(apt_frame, text="Quick Select:", font=self.medium_font).grid(
            row=1, column=2, sticky=tk.W, padx=(0, 20))
        
        self.apt_presets = ttk.Combobox(apt_frame, values=[
            "APT12 (G0103) - China",
            "APT29 (G0016) - Russia", 
            "Lazarus Group (G0032) - North Korea",
            "APT28 (G0007) - Russia",
            "APT1 (G0006) - China",
            "APT32 (G0050) - Vietnam",
            "APT34 (G0049) - Iran",
            "APT35 (G0059) - Iran",
            "Silent Librarian (G0122) - Iran",
            "PittyTiger (G0011) - China",
            "Putter Panda (G0024) - China",
            "Rocke (G0106) - China",
            "Scarlet Mimic (G0029) - China",
            "Suckfly (G0039) - China",
            "TA459 (G0126) - China",
            "Threat Group-3390 (G0027) - China",
            "Winnti Group (G0044) - China",
            "ZIRCONIUM (G0128) - China",
            "BlackTech (G0082) - China",
            "DragonOK (G0017) - China",
            "Dust Storm (G0030) - China",
            "DarkHydrus (G0079) - Iran",
            "Honeybee (G0072) - Unknown",
            "Overworm (G0071) - Unknown",
            "Sharpshooter (G0022) - Unknown",
            "Silence (G0001) - Unknown",
            "Sowbug (G0054) - Unknown",
            "BlackOasis (G0035) - Middle East",
            "Molerats (G0043) - Middle East",
            "WIRTE (G0090) - Middle East",
            "SilverTerrier (G0083) - Nigeria",
            "APT37 (G0067) - North Korea",
            "APT38 (G0082) - North Korea",
            "Kimsuky (G0094) - North Korea",
            "Stolen Pencil (G0086) - North Korea",
            "Gorgon Group (G0078) - Pakistan",
            "Magic Hound (G0059) - Iran",
            "MuddyWater (G0069) - Iran",
            "OilRig (G0049) - Iran",
            "TEMP.Veles (G0086) - Russia",
            "Turla (G0010) - Russia",
            "Cobalt Group (G0080) - Russia"
        ], state="readonly", font=self.medium_font, width=35)
        self.apt_presets.grid(row=1, column=3, sticky=(tk.W, tk.E))
        self.apt_presets.bind('<<ComboboxSelected>>', self.on_apt_preset_select)
        
        # File Selection Section
        file_frame = ttk.LabelFrame(main_frame, text="üìÅ File Selection", padding="20")
        file_frame.grid(row=3, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(0, 20))
        file_frame.columnconfigure(1, weight=1)
        
        ttk.Label(file_frame, text="Input CSV File:", font=self.medium_font).grid(
            row=0, column=0, sticky=tk.W, padx=(0, 20))
        self.file_path_var = tk.StringVar()
        self.file_entry = ttk.Entry(file_frame, textvariable=self.file_path_var, 
                                   width=80, font=self.medium_font)
        self.file_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=(0, 20))
        
        ttk.Button(file_frame, text="üìÇ Browse", 
                  command=self.browse_file).grid(row=0, column=2, padx=(0, 20))
        
        # Download Options Section
        options_frame = ttk.LabelFrame(main_frame, text="‚öôÔ∏è Download Options", padding="20")
        options_frame.grid(row=4, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(0, 20))
        
        ttk.Label(options_frame, text="Max Downloads:", font=self.medium_font).grid(
            row=0, column=0, sticky=tk.W, padx=(0, 20))
        self.max_downloads_var = tk.StringVar(value="100")
        self.max_downloads_spinbox = ttk.Spinbox(options_frame, from_=1, to=1000, 
                                                textvariable=self.max_downloads_var, 
                                                width=15, font=self.medium_font)
        self.max_downloads_spinbox.grid(row=0, column=1, sticky=tk.W, padx=(0, 50))
        
        # Progress Section
        progress_frame = ttk.LabelFrame(main_frame, text="üìä Download Progress", padding="20")
        progress_frame.grid(row=5, column=0, columnspan=4, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 20))
        progress_frame.columnconfigure(0, weight=1)
        progress_frame.rowconfigure(0, weight=1)
        main_frame.rowconfigure(5, weight=1)
        
        # Larger text area for logs
        self.log_text = scrolledtext.ScrolledText(progress_frame, height=20, width=100, 
                                                 font=self.medium_font, wrap=tk.WORD)
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 20))
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(progress_frame, variable=self.progress_var, 
                                           maximum=100, length=800)
        self.progress_bar.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=(0, 15))
        
        # Status label
        self.status_var = tk.StringVar(value="‚úÖ Ready to start download")
        status_label = ttk.Label(progress_frame, textvariable=self.status_var, 
                                font=self.medium_font, foreground='dark green')
        status_label.grid(row=2, column=0, sticky=tk.W)
        
        # Control Buttons - Larger and more prominent
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=6, column=0, columnspan=4, pady=(20, 0))
        
        self.start_button = ttk.Button(button_frame, text="üöÄ Start Download", 
                                      command=self.start_download, style='Accent.TButton')
        self.start_button.grid(row=0, column=0, padx=(0, 20))
        
        self.stop_button = ttk.Button(button_frame, text="‚èπÔ∏è Stop Download", 
                                     command=self.stop_download_process, state=tk.DISABLED)
        self.stop_button.grid(row=0, column=1, padx=(0, 20))
        
        self.clear_button = ttk.Button(button_frame, text="üóëÔ∏è Clear Log", 
                                      command=self.clear_log)
        self.clear_button.grid(row=0, column=2, padx=(0, 20))
        
        ttk.Button(button_frame, text="üìÇ Open Output Folder", 
                  command=self.open_output_folder).grid(row=0, column=3, padx=(0, 20))
        
        ttk.Button(button_frame, text="üìä View Downloaded Files", 
                  command=self.view_downloaded_files).grid(row=0, column=4, padx=(0, 20))
        
        # Statistics Frame
        stats_frame = ttk.Frame(main_frame)
        stats_frame.grid(row=7, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(20, 0))
        stats_frame.columnconfigure(0, weight=1)
        
        self.stats_var = tk.StringVar(value="üì• Downloads: 0 | ‚ùå Failed: 0 | ‚è≠Ô∏è Skipped: 0")
        stats_label = ttk.Label(stats_frame, textvariable=self.stats_var, 
                               font=self.medium_font, foreground='dark blue')
        stats_label.grid(row=0, column=0, sticky=tk.W)
        
        # Session stats
        self.session_stats_var = tk.StringVar(value="üíº Session: 0 downloaded, 0 failed, 0 skipped")
        session_stats_label = ttk.Label(stats_frame, textvariable=self.session_stats_var, 
                                       font=self.medium_font, foreground='dark green')
        session_stats_label.grid(row=0, column=1, sticky=tk.E)
    
    def toggle_api_key_visibility(self):
        """Toggle API key visibility"""
        if self.show_key_var.get():
            self.api_key_entry.config(show="")
        else:
            self.api_key_entry.config(show="*")
    
    def log_message(self, message):
        """Add message to log with timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        formatted_message = f"[{timestamp}] {message}\n"
        self.log_text.insert(tk.END, formatted_message)
        self.log_text.see(tk.END)
        self.root.update_idletasks()
    
    def clear_log(self):
        """Clear the log text area"""
        self.log_text.delete(1.0, tk.END)
    
    def save_api_key(self):
        """Save API key to config file"""
        api_key = self.api_key_var.get().strip()
        if api_key and api_key != "INSERT_YOUR_MALWAREBAZAAR_API_KEY":
            if not self.config.has_section('API'):
                self.config['API'] = {}
            self.config['API']['key'] = api_key
            self.save_config()
            messagebox.showinfo("Success", "‚úÖ API key saved successfully!")
            self.api_status_var.set("üü° API: Key Saved (Not Tested)")
        else:
            messagebox.showwarning("Warning", "‚ö†Ô∏è Please enter a valid API key")
    
    def test_api(self):
        """Test API authentication"""
        api_key = self.api_key_var.get().strip()
        if not api_key or api_key == "INSERT_YOUR_MALWAREBAZAAR_API_KEY":
            messagebox.showwarning("Warning", "‚ö†Ô∏è Please enter a valid API key first")
            return
        
        self.log_message("üß™ Testing API authentication...")
        
        # Test the API with a simple query
        test_downloader = MalwareBazaarDownloader(api_key)
        test_hash = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"  # Empty file hash
        
        try:
            file_info = test_downloader.get_file_info(test_hash)
            if file_info is not None:
                self.log_message("‚úÖ API authentication SUCCESSFUL")
                self.api_status_var.set("üü¢ API: Authentication Successful")
                messagebox.showinfo("API Test", "‚úÖ API authentication successful!\n\nYou can now proceed with downloads.")
            else:
                self.log_message("‚ùå API authentication FAILED - Invalid API key or network issue")
                self.api_status_var.set("üî¥ API: Authentication Failed")
                messagebox.showerror("API Test", "‚ùå API authentication failed!\n\nPlease check:\n‚Ä¢ Your API key\n‚Ä¢ Internet connection\n‚Ä¢ MalwareBazaar service status")
        except Exception as e:
            self.log_message(f"‚ùå API test error: {str(e)}")
            self.api_status_var.set("üî¥ API: Test Error")
            messagebox.showerror("API Test", f"‚ùå API test error: {str(e)}")
    
    def on_apt_preset_select(self, event):
        """Handle APT preset selection"""
        selection = self.apt_presets.get()
        if selection:
            # Parse the selection and set appropriate values
            preset_mapping = {
                "APT12 (G0103) - China": ("APT12", "G0103", "China"),
                "APT29 (G0016) - Russia": ("APT29", "G0016", "Russia"),
                "Lazarus Group (G0032) - North Korea": ("Lazarus Group", "G0032", "North Korea"),
                "APT28 (G0007) - Russia": ("APT28", "G0007", "Russia"),
                "APT1 (G0006) - China": ("APT1", "G0006", "China"),
                "APT32 (G0050) - Vietnam": ("APT32", "G0050", "Vietnam"),
                "APT34 (G0049) - Iran": ("APT34", "G0049", "Iran"),
                "APT35 (G0059) - Iran": ("APT35", "G0059", "Iran"),
                "Silent Librarian (G0122) - Iran": ("Silent Librarian", "G0122", "Iran"),
                "PittyTiger (G0011) - China": ("PittyTiger", "G0011", "China"),
                "Putter Panda (G0024) - China": ("Putter Panda", "G0024", "China"),
                "Rocke (G0106) - China": ("Rocke", "G0106", "China"),
                "Scarlet Mimic (G0029) - China": ("Scarlet Mimic", "G0029", "China"),
                "Suckfly (G0039) - China": ("Suckfly", "G0039", "China"),
                "TA459 (G0126) - China": ("TA459", "G0126", "China"),
                "Threat Group-3390 (G0027) - China": ("Threat Group-3390", "G0027", "China"),
                "Winnti Group (G0044) - China": ("Winnti Group", "G0044", "China"),
                "ZIRCONIUM (G0128) - China": ("ZIRCONIUM", "G0128", "China"),
                "BlackTech (G0082) - China": ("BlackTech", "G0082", "China"),
                "DragonOK (G0017) - China": ("DragonOK", "G0017", "China"),
                "Dust Storm (G0030) - China": ("Dust Storm", "G0030", "China"),
                "DarkHydrus (G0079) - Iran": ("DarkHydrus", "G0079", "Iran"),
                "Honeybee (G0072) - Unknown": ("Honeybee", "G0072", "Unknown"),
                "Overworm (G0071) - Unknown": ("Overworm", "G0071", "Unknown"),
                "Sharpshooter (G0022) - Unknown": ("Sharpshooter", "G0022", "Unknown"),
                "Silence (G0001) - Unknown": ("Silence", "G0001", "Unknown"),
                "Sowbug (G0054) - Unknown": ("Sowbug", "G0054", "Unknown"),
                "BlackOasis (G0035) - Middle East": ("BlackOasis", "G0035", "Middle East"),
                "Molerats (G0043) - Middle East": ("Molerats", "G0043", "Middle East"),
                "WIRTE (G0090) - Middle East": ("WIRTE", "G0090", "Middle East"),
                "SilverTerrier (G0083) - Nigeria": ("SilverTerrier", "G0083", "Nigeria"),
                "APT37 (G0067) - North Korea": ("APT37", "G0067", "North Korea"),
                "APT38 (G0082) - North Korea": ("APT38", "G0082", "North Korea"),
                "Kimsuky (G0094) - North Korea": ("Kimsuky", "G0094", "North Korea"),
                "Stolen Pencil (G0086) - North Korea": ("Stolen Pencil", "G0086", "North Korea"),
                "Gorgon Group (G0078) - Pakistan": ("Gorgon Group", "G0078", "Pakistan"),
                "Magic Hound (G0059) - Iran": ("Magic Hound", "G0059", "Iran"),
                "MuddyWater (G0069) - Iran": ("MuddyWater", "G0069", "Iran"),
                "OilRig (G0049) - Iran": ("OilRig", "G0049", "Iran"),
                "TEMP.Veles (G0086) - Russia": ("TEMP.Veles", "G0086", "Russia"),
                "Turla (G0010) - Russia": ("Turla", "G0010", "Russia"),
                "Cobalt Group (G0080) - Russia": ("Cobalt Group", "G0080", "Russia")
            }
            
            if selection in preset_mapping:
                group_name, mitre_id, country = preset_mapping[selection]
                self.group_name_var.set(group_name)
                self.mitre_id_var.set(mitre_id)
                self.country_var.set(country)
                self.log_message(f"üéØ Selected APT group: {group_name} ({mitre_id}) from {country}")
    
    def browse_file(self):
        """Browse for CSV file"""
        filename = filedialog.askopenfilename(
            title="Select CSV file with SHA256 hashes",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        if filename:
            self.file_path_var.set(filename)
            self.log_message(f"üìÅ Selected file: {filename}")
    
    def open_output_folder(self):
        """Open the output folder in file explorer"""
        try:
            if os.path.exists("Executables") or os.path.exists("NonExecutables"):
                if platform.system() == "Windows":
                    os.startfile(".")
                elif platform.system() == "Darwin":  # macOS
                    subprocess.run(["open", "."])
                else:  # Linux
                    subprocess.run(["xdg-open", "."])
                self.log_message("üìÇ Opened output folder in file explorer")
            else:
                messagebox.showinfo("Info", "Output folder will be created after first download")
        except Exception as e:
            messagebox.showerror("Error", f"Cannot open folder: {e}")
    
    def view_downloaded_files(self):
        """Show downloaded files count and details"""
        try:
            executable_count = 0
            non_executable_count = 0
            total_size = 0
            
            # Count executables
            if os.path.exists("Executables"):
                for file in os.listdir("Executables"):
                    file_path = os.path.join("Executables", file)
                    if os.path.isfile(file_path):
                        executable_count += 1
                        total_size += os.path.getsize(file_path)
            
            # Count non-executables
            if os.path.exists("NonExecutables"):
                for file in os.listdir("NonExecutables"):
                    file_path = os.path.join("NonExecutables", file)
                    if os.path.isfile(file_path):
                        non_executable_count += 1
                        total_size += os.path.getsize(file_path)
            
            total_files = executable_count + non_executable_count
            total_size_mb = total_size / (1024 * 1024)
            
            message = f"""
üìä Downloaded Files Summary:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üì¶ Executable Files: {executable_count}
üìÑ Non-Executable Files: {non_executable_count}
üìÅ Total Files: {total_files}
üíæ Total Size: {total_size_mb:.2f} MB

üíº Current Session:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚úÖ Downloaded: {self.total_downloaded}
‚ùå Failed: {self.total_failed}
‚è≠Ô∏è Skipped: {self.total_skipped}
"""
            messagebox.showinfo("üìä Downloaded Files Summary", message)
            self.log_message("üìä Displayed downloaded files summary")
            
        except Exception as e:
            messagebox.showerror("Error", f"Cannot read downloaded files: {e}")
    
    def validate_inputs(self):
        """Validate all input fields"""
        if not self.api_key_var.get() or self.api_key_var.get() == "INSERT_YOUR_MALWAREBAZAAR_API_KEY":
            messagebox.showerror("Error", "‚ùå Please enter your MalwareBazaar API key")
            return False
        
        if "API: Authentication Successful" not in self.api_status_var.get():
            result = messagebox.askyesno("API Not Tested", 
                                       "‚ö†Ô∏è You haven't tested the API yet. Continue anyway?")
            if not result:
                return False
        
        if not self.group_name_var.get():
            messagebox.showerror("Error", "‚ùå Please enter APT group name")
            return False
        
        if not self.mitre_id_var.get():
            messagebox.showerror("Error", "‚ùå Please enter MITRE ID")
            return False
        
        if not self.file_path_var.get() or not os.path.exists(self.file_path_var.get()):
            messagebox.showerror("Error", "‚ùå Please select a valid CSV file")
            return False
        
        try:
            max_downloads = int(self.max_downloads_var.get())
            if max_downloads <= 0:
                raise ValueError
        except ValueError:
            messagebox.showerror("Error", "‚ùå Please enter a valid number for max downloads")
            return False
        
        return True
    
    def start_download(self):
        """Start the download process in a separate thread"""
        if not self.validate_inputs():
            return
        
        self.stop_download = False
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        
        # Reset session statistics
        self.total_downloaded = 0
        self.total_failed = 0
        self.total_skipped = 0
        self.update_session_stats()
        
        # Get APT group info
        apt_group_info = {
            "name": self.group_name_var.get(),
            "mitre_id": self.mitre_id_var.get(),
            "country": self.country_var.get()
        }
        
        # Start download in separate thread
        self.download_thread = Thread(target=self.run_download, args=(apt_group_info,))
        self.download_thread.daemon = True
        self.download_thread.start()
    
    def stop_download_process(self):
        """Stop the download process"""
        self.stop_download = True
        self.status_var.set("üõë Stopping...")
        self.log_message("‚èπÔ∏è Download process stopping...")
    
    def run_download(self, apt_group_info):
        """Run the download process (in thread)"""
        try:
            # Initialize downloader
            self.downloader = MalwareBazaarDownloader(self.api_key_var.get())
            
            # Process CSV file
            max_downloads = int(self.max_downloads_var.get())
            input_csv = self.file_path_var.get()
            
            self.log_message(f"üöÄ Starting download for {apt_group_info['name']} ({apt_group_info['mitre_id']})")
            self.log_message(f"üìÅ Input file: {input_csv}")
            self.log_message(f"üéØ Max downloads: {max_downloads}")
            self.log_message("‚îÄ" * 60)
            
            # Run the download process
            self.downloader.process_csv_gui(
                input_csv=input_csv,
                apt_group_info=apt_group_info,
                max_downloads=max_downloads,
                gui_callback=self.update_gui_progress
            )
            
            if not self.stop_download:
                self.status_var.set("‚úÖ Download completed")
                self.log_message("üéâ Download process completed successfully!")
                self.log_message(f"üìä Session Summary: {self.total_downloaded} downloaded, {self.total_failed} failed, {self.total_skipped} skipped")
            
        except Exception as e:
            self.log_message(f"‚ùå ERROR: {str(e)}")
            self.status_var.set("‚ùå Error occurred")
        
        finally:
            # Re-enable buttons
            self.root.after(0, self.enable_buttons)
    
    def update_session_stats(self):
        """Update session statistics display"""
        self.session_stats_var.set(f"üíº Session: {self.total_downloaded} downloaded, {self.total_failed} failed, {self.total_skipped} skipped")
    
    def update_gui_progress(self, current, total, downloaded, failed, skipped, message):
        """Update GUI progress from downloader thread"""
        if self.stop_download:
            return False  # Signal to stop
        
        # Update session statistics
        self.total_downloaded = downloaded
        self.total_failed = failed
        self.total_skipped = skipped
        
        # Update progress in thread-safe manner
        self.root.after(0, self._update_progress, current, total, downloaded, failed, skipped, message)
        return True  # Continue
    
    def _update_progress(self, current, total, downloaded, failed, skipped, message):
        """Thread-safe GUI update"""
        if message:
            self.log_message(message)
        
        # Update progress bar
        if total > 0:
            progress = (current / total) * 100
            self.progress_var.set(progress)
        
        # Update status
        if total > 0:
            self.status_var.set(f"üîÑ Processing {current}/{total} hashes ({progress:.1f}%)")
        else:
            self.status_var.set(f"üîÑ Processing...")
        
        # Update statistics
        self.stats_var.set(f"üì• Downloads: {downloaded} | ‚ùå Failed: {failed} | ‚è≠Ô∏è Skipped: {skipped}")
        self.update_session_stats()
    
    def enable_buttons(self):
        """Re-enable control buttons"""
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)
        self.progress_var.set(0)


class MalwareBazaarDownloader:
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.base_url = "https://mb-api.abuse.ch/api/v1/"
        self.rate_limiter = Semaphore(3)
        self.request_times = []
        
        # Create output directories - CORRECTED to use "NonExecutables" (plural)
        os.makedirs("Executables", exist_ok=True)
        os.makedirs("NonExecutables", exist_ok=True)
        
        # File type classifications
        self.executable_extensions = {'.exe', '.dll', '.scr', '.com', '.bat', '.cmd', 
                                    '.ps1', '.vbs', '.js', '.msi', '.sys', '.ocx', 
                                    '.apk', '.jar', '.app', '.ipa', '.deb', '.rpm'}
        
        self.non_executable_extensions = {'.pdf', '.doc', '.docx', '.xls', '.xlsx', 
                                        '.ppt', '.pptx', '.txt', '.rtf', '.odt', 
                                        '.ods', '.odp', '.jpg', '.jpeg', '.png', 
                                        '.gif', '.bmp', '.tiff', '.mp3', '.mp4', 
                                        '.avi', '.mov', '.csv', '.json', '.xml', 
                                        '.html', '.htm', '.log'}

    def _apply_rate_limit(self):
        """Apply rate limiting to respect API limits"""
        self.rate_limiter.acquire()
        current_time = time.time()
        
        # Remove requests older than 60 seconds
        self.request_times = [t for t in self.request_times if current_time - t < 60]
        
        # If we've made 3 requests in the last 60 seconds, wait
        if len(self.request_times) >= 3:
            sleep_time = 60 - (current_time - self.request_times[0])
            if sleep_time > 0:
                time.sleep(sleep_time)
                self.request_times.pop(0)
        
        self.request_times.append(current_time)
        self.rate_limiter.release()

    def get_file_info(self, sha256_hash):
        """Get file information from MalwareBazaar API"""
        self._apply_rate_limit()
        
        data = {"query": "get_info", "hash": sha256_hash}
        headers = {'API-Key': self.api_key, 'Accept': 'application/json'}
        
        try:
            response = requests.post(self.base_url, data=data, headers=headers, timeout=30)
            response.raise_for_status()
            result = response.json()
            
            if result.get('query_status') == 'ok':
                return result['data'][0]
            else:
                return None
                
        except requests.exceptions.RequestException:
            return None

    def download_file(self, sha256_hash):
        """Download file from MalwareBazaar"""
        self._apply_rate_limit()
        
        data = {"query": "get_file", "sha256_hash": sha256_hash}
        headers = {'API-Key': self.api_key, 'Accept': 'application/json'}
        
        try:
            response = requests.post(self.base_url, data=data, headers=headers, timeout=60)
            response.raise_for_status()
            
            result = response.json()
            if result.get('query_status') == 'ok':
                download_url = result['data'][0]['file']
                file_response = requests.get(download_url, timeout=60)
                file_response.raise_for_status()
                return file_response.content
            else:
                return None
                
        except requests.exceptions.RequestException:
            return None

    def classify_file(self, file_info, filename):
        """Classify file as executable or non-executable"""
        extension = os.path.splitext(filename)[1].lower()
        
        if extension in self.executable_extensions:
            return "Executable", f"Executable file extension: {extension}"
        elif extension in self.non_executable_extensions:
            return "NonExecutable", f"Non-executable file extension: {extension}"
        
        file_type = file_info.get('file_type', '').lower()
        signature = file_info.get('signature', '').lower()
        
        executable_indicators = ['exe', 'dll', 'executable', 'pe32', 'pe64', 'elf', 
                               'windows', 'application', 'installer', 'binary']
        
        for indicator in executable_indicators:
            if indicator in file_type or indicator in signature:
                return "Executable", f"File type indicates executable: {file_type}"
        
        return "NonExecutable", "Conservative classification - defaulting to non-executable"

    def generate_filename(self, sha256_hash, file_info):
        """Generate appropriate filename for downloaded file"""
        file_name = file_info.get('file_name', '')
        if file_name:
            return file_name
        
        file_type = file_info.get('file_type', '').lower()
        if 'pe32' in file_type or 'pe64' in file_type:
            extension = '.exe'
        elif 'pdf' in file_type:
            extension = '.pdf'
        elif 'zip' in file_type:
            extension = '.zip'
        elif 'document' in file_type:
            extension = '.doc'
        else:
            extension = '.bin'
        
        return f"{sha256_hash[:16]}_sample{extension}"

    def save_metadata(self, apt_group_info, file_info, classification, filename, file_size):
        """Save metadata about downloaded file"""
        metadata_file = f"{apt_group_info['mitre_id']}_{apt_group_info['name']}_Malware_Metadata.csv"
        
        file_exists = os.path.exists(metadata_file)
        
        with open(metadata_file, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            if not file_exists:
                writer.writerow([
                    'FileName', 'APTGroup', 'MITREID', 'Country', 
                    'PayloadType', 'SHA256', 'SourceURL', 'DownloadDate',
                    'FileSize', 'FileType', 'Signature', 'FirstSeen',
                    'ClassificationReason', 'Status'
                ])
            
            writer.writerow([
                filename,
                apt_group_info['name'],
                apt_group_info['mitre_id'],
                apt_group_info.get('country', ''),
                classification[0],
                file_info.get('sha256_hash', ''),
                'https://mb-api.abuse.ch/api/v1/',
                datetime.now().isoformat(),
                file_size,
                file_info.get('file_type', ''),
                file_info.get('signature', ''),
                file_info.get('first_seen', ''),
                classification[1],
                'Downloaded'
            ])

    def save_failed_attempt(self, apt_group_info, sha256_hash, reason):
        """Save information about failed download attempts"""
        metadata_file = f"{apt_group_info['mitre_id']}_{apt_group_info['name']}_Malware_Metadata.csv"
        
        file_exists = os.path.exists(metadata_file)
        
        with open(metadata_file, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            if not file_exists:
                writer.writerow([
                    'FileName', 'APTGroup', 'MITREID', 'Country', 
                    'PayloadType', 'SHA256', 'SourceURL', 'DownloadDate',
                    'FileSize', 'FileType', 'Signature', 'FirstSeen',
                    'ClassificationReason', 'Status'
                ])
            
            writer.writerow([
                f"{sha256_hash[:16]}_failed",
                apt_group_info['name'],
                apt_group_info['mitre_id'],
                apt_group_info.get('country', ''),
                'Unknown',
                sha256_hash,
                'https://mb-api.abuse.ch/api/v1/',
                datetime.now().isoformat(),
                '',
                '',
                '',
                '',
                reason,
                'Failed'
            ])

    def is_valid_sha256(self, hash_string):
        """Validate SHA256 hash format"""
        if not hash_string or len(hash_string) != 64:
            return False
        try:
            int(hash_string, 16)
            return True
        except ValueError:
            return False

    def process_csv_gui(self, input_csv, apt_group_info, max_downloads, gui_callback):
        """Process CSV with GUI callback support"""
        if not os.path.exists(input_csv):
            gui_callback(0, 0, 0, 0, 0, "‚ùå Input file not found")
            return
        
        valid_hashes = []
        
        try:
            with open(input_csv, 'r', newline='', encoding='utf-8') as file:
                sample = file.read(1024)
                file.seek(0)
                
                if 'SHA256' in sample or 'sha256' in sample or 'SHA256_Hash' in sample:
                    reader = csv.DictReader(file)
                    
                    for row_num, row in enumerate(reader, 1):
                        sha256_hash = None
                        for col_name in ['SHA256', 'sha256', 'SHA256_Hash', 'hash', 'Hash']:
                            if col_name in row and row[col_name]:
                                sha256_hash = row[col_name].strip()
                                break
                        
                        if sha256_hash and self.is_valid_sha256(sha256_hash):
                            valid_hashes.append(sha256_hash)
                            
                else:
                    for line_num, line in enumerate(file, 1):
                        line = line.strip()
                        if self.is_valid_sha256(line):
                            valid_hashes.append(line)
                            
        except Exception as e:
            gui_callback(0, 0, 0, 0, 0, f"‚ùå Error reading CSV file: {e}")
            return
        
        total_hashes = len(valid_hashes)
        gui_callback(0, total_hashes, 0, 0, 0, f"üéØ Found {total_hashes} valid SHA256 hashes")
        
        if total_hashes == 0:
            gui_callback(0, 0, 0, 0, 0, "‚ùå No valid SHA256 hashes found")
            return
        
        downloaded_count = 0
        failed_count = 0
        skipped_count = 0
        
        for i, sha256_hash in enumerate(valid_hashes, 1):
            if max_downloads and downloaded_count >= max_downloads:
                gui_callback(i, total_hashes, downloaded_count, failed_count, skipped_count, 
                           f"üéØ Reached maximum download limit: {max_downloads}")
                break
            
            # Check if GUI wants to stop
            if not gui_callback(i, total_hashes, downloaded_count, failed_count, skipped_count, 
                              f"üîç Processing: {sha256_hash[:16]}..."):
                break
            
            success = self.process_single_hash_gui(sha256_hash, apt_group_info, gui_callback)
            
            if success:
                downloaded_count += 1
                gui_callback(i, total_hashes, downloaded_count, failed_count, skipped_count,
                           f"‚úÖ Downloaded: {sha256_hash[:16]}")
            else:
                failed_count += 1
            
            time.sleep(1)  # Rate limiting between downloads
        
        gui_callback(total_hashes, total_hashes, downloaded_count, failed_count, skipped_count,
                    f"üéØ Final: {downloaded_count} downloaded, {failed_count} failed, {skipped_count} skipped")

    def process_single_hash_gui(self, sha256_hash, apt_group_info, gui_callback):
        """Process single hash with GUI updates"""
        if not self.is_valid_sha256(sha256_hash):
            gui_callback(0, 0, 0, 0, 0, f"‚ùå Invalid SHA256 hash: {sha256_hash}")
            return False
        
        file_info = self.get_file_info(sha256_hash)
        if not file_info:
            gui_callback(0, 0, 0, 0, 0, f"‚ùå File not found in MalwareBazaar: {sha256_hash[:16]}")
            self.save_failed_attempt(apt_group_info, sha256_hash, "File not found")
            return False
        
        file_content = self.download_file(sha256_hash)
        if not file_content:
            gui_callback(0, 0, 0, 0, 0, f"‚ùå Download failed: {sha256_hash[:16]}")
            self.save_failed_attempt(apt_group_info, sha256_hash, "Download failed")
            return False
        
        filename = self.generate_filename(sha256_hash, file_info)
        classification = self.classify_file(file_info, filename)
        
        # CORRECTED: Use "NonExecutables" instead of "NonExecutable"
        folder = "Executables" if classification[0] == "Executable" else "NonExecutables"
        filepath = os.path.join(folder, filename)
        
        with open(filepath, 'wb') as f:
            f.write(file_content)
        
        file_size = len(file_content)
        self.save_metadata(apt_group_info, file_info, classification, filename, file_size)
        
        gui_callback(0, 0, 0, 0, 0, f"üìÅ Saved: {filename} -> {folder} ({file_size} bytes)")
        return True


if __name__ == "__main__":
    root = tk.Tk()
    app = MalwareBazaarDownloaderGUI(root)
    root.mainloop()